# Game Engine Architecture

## Rendering

---------------------
[Course Index](http://nikoladimitroff.github.io/Game-Engine-Architecture)

<div class="authors-section">
<table>
<tbody>
    <tr>
        <td>
            Nikola Dimitroff
        </td>
        <td>
            <a target="_blank" href="https://dimitroff.bg"><i class="fa fa-rss"></i></a>
            <a target="_blank" href="mailto:nikola@dimitroff.bg"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/nikoladimitroff"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/nikoladimitroff"><i class="fa fa-twitter"></i></a>
        </td>
    </tr>
    <tr>
        <td>
            Alexander Angelov
        </td>
        <td>
            <a target="_blank" href="mailto:aleksandar.angelovv@gmail.com"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/Alekssasho"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/Alekssasho"><i class="fa fa-twitter"></i></a>
        </td>
    </tr>
    <tr>
        <td>
            Viktor Ketipov
        </td>
        <td>
            <a target="_blank" href="mailto:viktor@kipiinteractive.com"><i class="fa fa-envelope-o"></i></a>
            <a target="_blank" href="https://github.com/k1p1"><i class="fa fa-github"></i></a>
            <a target="_blank" href="https://twitter.com/xk1p1x"><i class="fa fa-twitter"></i></a></p>
        </td>
    </tr>
</tbody>
</table>
</div>

<div class="companies-section">
<a class="ubisoft-logo" href="https://ubisoft.com" target="_blank"></a>
<br>
<a class="kipi-logo" href="http://kipiinteractive.com" target="_blank"></a>
</div>

--- NEXT SLIDE ---

# Sanity check

We are recording, aren't we?

![kitty cameraman](http://www.catster.com/wp-content/uploads/2015/06/335f4392f011a80324e09f5ace0b3f57.jpg)

--- NEXT SLIDE ---

## Review

Why isn't ray tracing appropriate for real time rendering?

<!-- .element class="fragment" data-fragment-index="0" --> Really slow because each pixel needs tracing of many rays.

--- VERTICAL SLIDE ---

## Review

What is Global Lighting and how it is approximated in the Phong lighting model?

* <!-- .element class="fragment" data-fragment-index="0" --> Indirect light in the scene
* <!-- .element class="fragment" data-fragment-index="0" --> Ambient coefficient which is added as constant

--- VERTICAL SLIDE ---

## Review

What is the difference between orthographics and perspective projection?

<!-- .element class="fragment" data-fragment-index="0" --> Orthographics preserve relative sizes and parallel lines.

--- NEXT SLIDE ---

## Quick Recap

- Scene into
- Meshes into
- Triangles & Materials

- Camera & Lighting

--- NEXT SLIDE ---

## Color theory

..in 2 minutes

![Color kitties](https://s-media-cache-ak0.pinimg.com/736x/a8/70/34/a870340d668edfd6b7c719913480a60e.jpg)

--- VERTICAL SLIDE ---

### RGB

![RGB model](https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/RGB_Cube_Show_lowgamma_cutout_b.png/512px-RGB_Cube_Show_lowgamma_cutout_b.png)

--- VERTICAL SLIDE ---

### HSL

![HSL](https://upload.wikimedia.org/wikipedia/commons/2/2d/HSL_color_solid_dblcone.png)

--- NEXT SLIDE ---

## Rendering Pipeline

--- VERTICAL SLIDE ---

* Tools stage (offline). Geometry and surface properties (materials) are defined.
* Asset conditioning stage (offline). The geometry and material data are processed
by the asset conditioning pipeline (ACP) into an engine-ready
format.

--- VERTICAL SLIDE ---

* Application stage (CPU). Potentially visible mesh instances are identified
and submitted to the graphics hardware along with their materials for
rendering.

* Geometry processing stage (GPU). Vertices are transformed, lit and projected
into homogeneous clip space. Triangles are processed by the optional
geometry shader and then clipped to the frustum.

* Rasterization stage (GPU). Triangles are converted into pixels that are
shaded (coloured), passed through various tests (e.g. z-test)
and finally blended into the frame buffer.

--- VERTICAL SLIDE ---

![Pipeline](resources/10.rendering/pipeline.jpg)

--- NEXT SLIDE ---

## GPU Architecture

![GPUArch](http://www.keremcaliskan.com/wp-content/uploads/2011/01/CPU-GPU-Structures1.png)

--- VERTICAL SLIDE ---

## throughput vs latency

--- NEXT SLIDE ---

## GPU pipeline

--- VERTICAL SLIDE ---

![GPU Pipeline](https://traxnet.files.wordpress.com/2011/07/shader_full.jpeg)

--- NEXT SLIDE ---

## The hardware device

Abstracts the GPU for you

* DirectX
* OpenGL
* Console-specific
* Console on nonconsoles - DX12, Vulcan, Metal

--- VERTICAL SLIDE ---

## The shader model

The set of features supported by your GPU

* Shader model 6 is the latest and greatest

--- VERTICAL SLIDE ---

## Working with a graphics-device overview

* Initializing the device
* Using the device to create helper objects
    - Render targets
    - Textures
    - Buffers
    - Samplers, Scissors, etc.
* Binding the state
* Drawing

--- VERTICAL SLIDE ---

### Initialize the device

```cpp
// Create the swap chain, Direct3D device, and Direct3D device context.
result = D3D11CreateDeviceAndSwapChain(
   NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, 0, &featureLevel, 1,
   D3D11_SDK_VERSION,
   &swapChainDesc, &m_SwapChain, &m_Devic, NULL, &m_Context);
if (FAILED(result))
{
    // Error
}
```

--- VERTICAL SLIDE ---

### Creating a resource

```cpp
D3D11_TEXTURE2D_DESC desc = { 0 };
desc.Width = 1920;
desc.Height = 1080;
desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
desc.Usage = D3D11_USAGE_DEFAULT;
desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
D3D11_SUBRESOURCE_DATA* init = nullptr;

ID3D11Texture2D* resource;
HRESULT hr = m_Device->CreateTexture2D(&desc, init, &resource);
if (FAILED(hr))
{
    // Error
}
// Use the texture
```

--- VERTICAL SLIDE ---

### Binding state

```cpp
ID3D11ShaderResourceView* textures[MAX_TEXTURES_COUNT];
textures[0] = myTexture;
m_Context->PSSetShaderResources(0, 1, textures);

m_Context->VSSetShader(currentVS, nullptr, 0);
m_Context->PSSetShader(currentPS, nullptr, 0);
```

--- VERTICAL SLIDE ---

### Drawing

```cpp
m_Context->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
m_Context->DrawIndexed(indexCount, startIndex, baseVertexIndex);
```

--- VERTICAL SLIDE ---

### Draw loop

```cpp
SortObjectsByShaderThenByMaterial();
SetState();
for(all shaders)
    SetShaders();
    for(all materials)
        SetMaterialProperties();
        for(all meshes)
            Draw();
```

--- VERTICAL SLIDE ---

### HLSL

```cpp
struct VertexShaderInput
{
  float4 Position  : POSITION0;
  float3 Normal    : NORMAL0;
  float2 TexCoords : TEXCOORD0;
};
```

--- VERTICAL SLIDE ---

```cpp
VertexShaderOutput VertexShaderFunction(VertexShaderInput input)
{
  VertexShaderOutput output;
  float4 posWorld = mul(input.Position, World);
  output.Position = mul(posWorld, ViewProjection);
  output.TexCoords = input.TexCoords;
  output.Normal = mul(input.Normal, (float3x3)World);
  output.WorldPos = posWorld;
  return output;
}
```

--- VERTICAL SLIDE ---

```cpp
float4 PixelShaderFunction(VertexShaderOutput input) : COLOR0
{
  // Get light direction for this fragment
  float3 lightDir = normalize(input.WorldPos - LightPosition);
  float diffuseLighting = saturate(dot(input.Normal, -lightDir));
  // Using Blinn half angle modification for performance over correctness
  float3 h = normalize(normalize(CameraPos - input.WorldPos) - lightDir);
  float specLighting = pow(saturate(dot(h, input.Normal)), SpecularPower);

  return float4(
    AmbientLightColor +
    (DiffuseColor * LightDiffuseColor * diffuseLighting ) +
    (SpecularColor * LightSpecularColor * specLighting));
  }
```

--- NEXT SLIDE ---

## Rendering dictionary

--- VERTICAL SLIDE ---

### Anti-Aliasing

![AA Comp](http://techreport.com/r.x/gtx-680-followup/txaa-comparo.png)

--- VERTICAL SLIDE ---

### LOD (Level of Detail)

![LOD](http://wiki.thesimsresource.com/images/thumb/0/03/LODHair.jpg/740px-LODHair.jpg)

--- VERTICAL SLIDE ---

### Aspect ratio

![AspectRatio](https://adferoafferro.files.wordpress.com/2013/12/film-aspect-ratio-2-combined.gif)

--- VERTICAL SLIDE ---

### Field of view (FOV)

![FOV](http://vr-lens-lab.com/wp-content/uploads/2016/03/monobino-1030x779.jpg)

--- NEXT SLIDE ---

## Forward Rendering and Deferred Rendering

--- VERTICAL SLIDE ---

Forward Rendering

![Forward Rendering](https://cdn.tutsplus.com/gamedev/uploads/2013/11/forward-v2.png)

--- VERTICAL SLIDE ---

Deffered Rendering

![Forward Rendering](https://cdn.tutsplus.com/gamedev/uploads/2013/11/deferred-v2.png)

--- VERTICAL SLIDE ---

G-Buffer

![GBuffer](http://ogldev.atspace.co.uk/www/tutorial35/gbuffer.jpg)

--- NEXT SLIDE ---

Implementation details

- single-threaded
- multi-threaded
- task based

--- NEXT SLIDE ---

## GPU Debugging

--- VERTICAL SLIDE ---

Every vendor has custom tools

- NVidia NSight
- AMD Perf Studio
- PIX
- Renderdoc

--- VERTICAL SLIDE ---

![renderdoc](https://www.cryengine.com/assets/images/showcase/fullsize/renderdoc1.png)

--- NEXT SLIDE ---
Graphical Processing Units

--- VERTICAL SLIDE ---
Definitions
* Latency
 *  Time to finish a fixed task
  *   33 or 16 ms frame ( 30 or 60 fps)
  *   15 ns for inserting an element into a queue
Throughput
* Tasks per unit time
  *  16 GB/s memory transfer
  *  4 Megapixels/s shading samples

--- VERTICAL SLIDE ---
Processor history

* Moore’s law
 * The number of transistors can be doubled every (1.5 years) (1969)
* Performance
  * Transistor performance. 
   * Improves linearly as size scales down
  * Wires scale poorly. 
   * Delays are increased, signals are lost. Relays are installed
   * 2 km of wiring on AMD Rysen

--- VERTICAL SLIDE ---
Processor history

* TDP – Thermal design power
  * Determines cooling requirements. Measured in watts (ex. 15W, 100W, 250W)
  * Power supply and cooling match and exceed TDP
  * Power = ½ Capacitive Load * Voltage ^ 2 * Frequency
  * Capacitive Load – function of number of transistors
  * Voltage – depends on transistors
  * Frequency can be adjusted

--- VERTICAL SLIDE ---
Obstacles to increasing frequency
![Obstacles](http://www.gotw.ca/images/CPU.png)

--- VERTICAL SLIDE ---
Memory barrier - DRAM
Year DRAM Growth Capacity
1990 60%/year 4x/3 years
1996 60%/year 4x/3 years
2003 40-60%/year 4x/3-4 years
2007 40%/year 2x/2 years
2011 - 25-40%/year 2x/2-3 years 

--- VERTICAL SLIDE ---
Capital for research

![renderdoc](http://www.yole.fr/iso_album/illus_annualcapitalexpenditure_standalonedram_yole_june2019_(430x278).jpg)

--- VERTICAL SLIDE ---
Memory barrier - speed

![Pipeline](resources/10.rendering/memory_barrier_speed.png)

* 1980: RAM latency ~ 1 cycle
* 2011: RAM latency ~ 150 - 400 + cycles

Sin(x) values in a table are faster in 1980

--- VERTICAL SLIDE ---
* CPU
  * Low latency, low throughput ( ns, < 100 GB/s )
* GPU
  * High latency, high throughput (ms, > 100 GB /s )

  AMD Athlon II x4 Radeon 5750
  TDP 95W 86W
  FLOPS 30 GFLOPS 1008 GFLOPS
  Transistors 300 M (768PH) 1040 M
  Bandwith GB/s 9 ( 4 OpenCL ) 70 ( 40 OpenCL )


--- VERTICAL SLIDE ---
CPU Components
* ALU
  * iompute
* Fetch
  * instructions stream, microops
* Execution context
  * registers, where is the program
* Branch predictor
  * conditions, if, else, while, for

--- VERTICAL SLIDE ---
CPU Components

* Out of order logic
 * tries to guess where the code will go 
* Memory prefetch
 * tries to fetch memory into the cache before it is used
* Data cache (varies)
 * L1 4ns 16Kib/32Kib
 * L2 40ns 256Kib/512Kib
 * L3 100ns 16Mib


--- NEXT SLIDE ---
DirectX 12 / Vulkan

--- VERTICAL SLIDE ---
DirectX 11 / OpenGL are delayed APIs By Design
* <!-- .element class="fragment" data-fragment-index="0" --> Basic problem, Frame time is unpredictable
* <!-- .element class="fragment" data-fragment-index="0" --> CPU is bottlenecked with work that may not be needed
* <!-- .element class="fragment" data-fragment-index="0" --> Pipeline states are set and parsed on draw call submission
* <!-- .element class="fragment" data-fragment-index="0" --> Triggers problems with resource usage
* <!-- .element class="fragment" data-fragment-index="0" --> Buffers my be bound on input or output operations
* <!-- .element class="fragment" data-fragment-index="0" --> Gpu Caches are flushed on every potentially every output set
* <!-- .element class="fragment" data-fragment-index="0" --> Hides memory residency

--- VERTICAL SLIDE ---
DirectX 11 / OpenGL are delayed APIs By Design
* <!-- .element class="fragment" data-fragment-index="0" --> Drivers spawn threads
* <!-- .element class="fragment" data-fragment-index="0" --> One thread per core (nvidia)
* <!-- .element class="fragment" data-fragment-index="0" --> Two core threads (intel)
* <!-- .element class="fragment" data-fragment-index="0" --> One thread for the immediate context (amd)
* <!-- .element class="fragment" data-fragment-index="0" --> They do interfere with the game threads.
* <!-- .element class="fragment" data-fragment-index="0" --> So what can we do?
* <!-- .element class="fragment" data-fragment-index="0" --> Optimize driver threads? Taxes all games, good ones and bad ones.
* <!-- .element class="fragment" data-fragment-index="0" --> If you do more work on the cpu on a laptop it remains less power for the GPU. They are tied together.

--- VERTICAL SLIDE ---
DirectX 11 / OpenGL are delayed APIs By Design
* <!-- .element class="fragment" data-fragment-index="0" --> Console developers had access to lower level GPU abstractions for years.
* <!-- .element class="fragment" data-fragment-index="0" --> Simplified apis, simplified os

--- VERTICAL SLIDE ---
DirectX 12 / Vulkan
* <!-- .element class="fragment" data-fragment-index="0" --> So what about if we level down the abstraction a bit ?
* <!-- .element class="fragment" data-fragment-index="0" --> Just little above the hardware level
* <!-- .element class="fragment" data-fragment-index="0" --> AMD did Mantle library, eventually turned out to be Vulkan  

--- VERTICAL SLIDE ---
Goals of DirectX 12

* <!-- .element class="fragment" data-fragment-index="0" --> Improve performance of CPU bound games
* <!-- .element class="fragment" data-fragment-index="0" --> Improve multicore scaling
* <!-- .element class="fragment" data-fragment-index="0" --> Improve performance on power constrained platforms
* <!-- .element class="fragment" data-fragment-index="0" --> Improve heat and battery life
* <!-- .element class="fragment" data-fragment-index="0" --> By reducing the CPU load

--- VERTICAL SLIDE ---
Main components of the API

* <!-- .element class="fragment" data-fragment-index="0" --> Memory
* <!-- .element class="fragment" data-fragment-index="0" --> Commands
* <!-- .element class="fragment" data-fragment-index="0" --> Synchronization
* <!-- .element class="fragment" data-fragment-index="0" --> Pipeline State
* <!-- .element class="fragment" data-fragment-index="0" --> Resource binding

--- VERTICAL SLIDE ---
Memory. One must manage memory by herself/himself. This is what the driver does

* <!-- .element class="fragment" data-fragment-index="0" --> Heaps
* <!-- .element class="fragment" data-fragment-index="0" --> What are resources?
* <!-- .element class="fragment" data-fragment-index="0" --> Textures, Index Buffers
* <!-- .element class="fragment" data-fragment-index="0" --> Shaders, Geometry, Buffers, ByteBuffers
* <!-- .element class="fragment" data-fragment-index="0" --> Subresources ?
* <!-- .element class="fragment" data-fragment-index="0" --> Mip 0, Mip 1 of  a texture
* <!-- .element class="fragment" data-fragment-index="0" --> Cube sides of a cube texture ?
* <!-- .element class="fragment" data-fragment-index="0" --> Texture in an array of textures.
* <!-- .element class="fragment" data-fragment-index="0" --> Reserved Resources
* <!-- .element class="fragment" data-fragment-index="0" --> Committed Resources
* <!-- .element class="fragment" data-fragment-index="0" --> Placed resources

--- VERTICAL SLIDE ---
Heaps

* <!-- .element class="fragment" data-fragment-index="0" --> Request an allocation of memory from the driver.
```cpp
d3d12device->CreateHeap( HeapDescription, Size in Bytes);
```

* <!-- .element class="fragment" data-fragment-index="0" --> Types of heaps
* <!-- .element class="fragment" data-fragment-index="0" --> VRAM of the GPU - accessed by the GPU only
* <!-- .element class="fragment" data-fragment-index="0" --> Geometry, Textures, Render Targets.
* <!-- .element class="fragment" data-fragment-index="0" --> Upload - used to transfer data across the PCI bus from the CPU to the GPU - Constants, Matrices, Streamed Geometry
* <!-- .element class="fragment" data-fragment-index="0" --> Readback - used to transfer back from the GPU - Screenshots
* <!-- .element class="fragment" data-fragment-index="0" --> Custom - UMA (consoles)

--- VERTICAL SLIDE ---
Now when one allocates the heap he must manage the memory inside. He/she must answer this questions:

* <!-- .element class="fragment" data-fragment-index="0" --> Creating resources inside, freeing resources
* <!-- .element class="fragment" data-fragment-index="0" --> How about multiple threads allocations?
* <!-- .element class="fragment" data-fragment-index="0" --> When I free something, does the gpu use it?
* <!-- .element class="fragment" data-fragment-index="0" --> What about the fragmentation of this memory?

* <!-- .element class="fragment" data-fragment-index="0" --> What about if the OS requires eviction?
* <!-- .element class="fragment" data-fragment-index="0" --> Alignment of resources
* <!-- .element class="fragment" data-fragment-index="0" --> 4 bytes for geometry
* <!-- .element class="fragment" data-fragment-index="0" --> 64KB for textures
* <!-- .element class="fragment" data-fragment-index="0" --> 4MB for MSAA render targets

--- VERTICAL SLIDE ---
When we create a heap accessible by the CPU

* <!-- .element class="fragment" data-fragment-index="0" --> Write Combine
* <!-- .element class="fragment" data-fragment-index="0" --> We must write there without holes.
* <!-- .element class="fragment" data-fragment-index="0" --> All member of the structures must be filled with data or 0.
* <!-- .element class="fragment" data-fragment-index="0" --> We bypass the cache system of the CPU. Reading is slow (hundreds of cycles)
* <!-- .element class="fragment" data-fragment-index="0" --> Suitable for write only data
* <!-- .element class="fragment" data-fragment-index="0" --> Bone Transforms is an example
* <!-- .element class="fragment" data-fragment-index="0" --> Write back
* <!-- .element class="fragment" data-fragment-index="0" --> Performs update of the page regularly
* <!-- .element class="fragment" data-fragment-index="0" --> So we may be able to write with holes or missing data.

--- VERTICAL SLIDE ---
DirectX 12 Descriptor Heaps

* <!-- .element class="fragment" data-fragment-index="0" --> We need a way to pass pointers to the GPU data around the code and dereference it on the GPU (shaders)
* <!-- .element class="fragment" data-fragment-index="0" --> On the cpu you have int32_t* or HANDLE that points to an address and you copy them around and dereference
```cpp
d3d12devicommandList->OMSetRenderTarget( gpuPointer )
```
* <!-- .element class="fragment" data-fragment-index="0" --> Descriptors come to replace the pointers for the gpu data
* <!-- .element class="fragment" data-fragment-index="0" --> They are abstraction, usually 64 or 128 bytes.

--- VERTICAL SLIDE ---
DirectX 12 Descriptor Heaps

* <!-- .element class="fragment" data-fragment-index="0" --> The driver stores data inside.
* <!-- .element class="fragment" data-fragment-index="0" --> You can create them with GPU memory
* <!-- .element class="fragment" data-fragment-index="0" --> You can copy them around to the command lists
* <!-- .element class="fragment" data-fragment-index="0" --> And you must ensure that they point to valid GPU data when used
* <!-- .element class="fragment" data-fragment-index="0" --> On the GPU

--- VERTICAL SLIDE ---
DirectX 12 Descriptor Heaps

* <!-- .element class="fragment" data-fragment-index="0" --> Descriptors are organized in a heap by types
* <!-- .element class="fragment" data-fragment-index="0" --> Shader Resource View (for reading from shaders)
* <!-- .element class="fragment" data-fragment-index="0" --> Render Target View ( for output from the shaders)
* <!-- .element class="fragment" data-fragment-index="0" --> Depth Stencil View (for the depth buffer).
* <!-- .element class="fragment" data-fragment-index="0" --> Sampler ( this is a special hardware that performs sampling )
* <!-- .element class="fragment" data-fragment-index="0" --> From the theory of signals
* <!-- .element class="fragment" data-fragment-index="0" --> Sampling means to read the values of the signals
* <!-- .element class="fragment" data-fragment-index="0" --> Geometry is a signal, Textures are signal.

--- VERTICAL SLIDE ---
DirectX 12 Examples

* <!-- .element class="fragment" data-fragment-index="0" -->Critical 
 * <!-- .element class="fragment" data-fragment-index="0" -->Must reside always
* <!-- .element class="fragment" data-fragment-index="0" --> Scaled Optional
 * <!-- .element class="fragment" data-fragment-index="0" --> Game Data - Art Supplied data
* <!-- .element class="fragment" data-fragment-index="0" --> Reused in a frame
 * <!-- .element class="fragment" data-fragment-index="0" --> Lighting Buffers, Skinning Buffers, Animation Buffers, Post Process Buffers
* <!-- .element class="fragment" data-fragment-index="0" --> Streaming resources
 * <!-- .element class="fragment" data-fragment-index="0" --> Terrain data or other big structures

--- VERTICAL SLIDE ---
Placed Resources

* <!-- .element class="fragment" data-fragment-index="0" --> Can be created in a heap.
 * <!-- .element class="fragment" data-fragment-index="0" --> Very lightweight. Can be created in a heap
  * <!-- .element class="fragment" data-fragment-index="0" --> You must manage the offset in the heap. Very useful for small data 4KB
  * <!-- .element class="fragment" data-fragment-index="0" --> Example: You allocate 32 MB for textures and manage the allocations by yourself. 
* <!-- .element class="fragment" data-fragment-index="0" --> Committed Resources
  * <!-- .element class="fragment" data-fragment-index="0" --> Backed by physical memory.
* <!-- .element class="fragment" data-fragment-index="0" --> Reserved resources
  * <!-- .element class="fragment" data-fragment-index="0" --> Allocates address space, without actual physical memory
  * <!-- .element class="fragment" data-fragment-index="0" --> Can be committed and decommitted on demand (through the device)

--- VERTICAL SLIDE ---
DIRECTX12 Work submission COMMANDS and QUEUES

* <!-- .element class="fragment" data-fragment-index="0" --> Commands, Bundles
* <!-- .element class="fragment" data-fragment-index="0" --> The CPU generates commands for the gpu in a format close the gpu
* <!-- .element class="fragment" data-fragment-index="0" --> Bundles are commands which are generated up front
* <!-- .element class="fragment" data-fragment-index="0" --> Commands are submitted in Command Lists
* <!-- .element class="fragment" data-fragment-index="0" --> Memory for Command Lists is managed by Command Allocators
* <!-- .element class="fragment" data-fragment-index="0" --> Generated commands are submitted through queues
* <!-- .element class="fragment" data-fragment-index="0" --> Queues can have different types of commands
* <!-- .element class="fragment" data-fragment-index="0" --> Direct, Bundle, Compute, Copy,  Video Decode, Video Encode
* <!-- .element class="fragment" data-fragment-index="0" --> Priority, how the OS treats the commands submitted there
* <!-- .element class="fragment" data-fragment-index="0" --> Queues can be mapped to hardware.
* <!-- .element class="fragment" data-fragment-index="0" --> Some AMD models have two queues
* <!-- .element class="fragment" data-fragment-index="0" --> Some have 64 queues
* <!-- .element class="fragment" data-fragment-index="0" --> Some have specialized queues for copy through DMA

--- VERTICAL SLIDE ---
DIRECTX12 Synchronization сFENCES

* <!-- .element class="fragment" data-fragment-index="0" --> Fences encapsulate values which increase monotonically in time.  App is responsible for increasing the fences
* <!-- .element class="fragment" data-fragment-index="0" --> Fence
* <!-- .element class="fragment" data-fragment-index="0" --> Can block a gpu queue to wait on another gpu queue
* <!-- .element class="fragment" data-fragment-index="0" --> Can block the cpu until the gpu passes a point
* <!-- .element class="fragment" data-fragment-index="0" --> Gpu
* <!-- .element class="fragment" data-fragment-index="0" --> queue->Signal(fence, 100);
* <!-- .element class="fragment" data-fragment-index="0" --> anotherQueue->Wait(fence, 100);
* <!-- .element class="fragment" data-fragment-index="0" --> Cpu
* <!-- .element class="fragment" data-fragment-index="0" --> m_fence->SetEventOnCompletion(fence, 100); WaitForSingleObject(fence, INFINITE);

--- VERTICAL SLIDE ---
DIRECTX12 Synchronization EXAMPLES

* <!-- .element class="fragment" data-fragment-index="0" --> Wait for the previous frame to finish in a double buffered scenario
* <!-- .element class="fragment" data-fragment-index="0" --> CPU Execute Commands ( frame n ), wait for the GPU to finish processing commands for frame n - 1
* <!-- .element class="fragment" data-fragment-index="0" --> Wait for the GPU to pass an execution point to transfer memory to the CPU
* <!-- .element class="fragment" data-fragment-index="0" --> Two queues graphic and compute work cooperatively to deliver better performance
* <!-- .element class="fragment" data-fragment-index="0" --> Combine memory graphics loads with compute loads

--- VERTICAL SLIDE ---
DIRECTX12 PIPELINESTATE
* <!-- .element class="fragment" data-fragment-index="0" --> Represents the whole GPU pipeline as a monolithic block
* <!-- .element class="fragment" data-fragment-index="0" --> Rasterizer, Blend State, Shaders, Depth, MSAA
* <!-- .element class="fragment" data-fragment-index="0" --> For compute just shaders
* <!-- .element class="fragment" data-fragment-index="0" --> On DX11 they are separate and the driver must check on every draw call if it was changed and rebuild
* <!-- .element class="fragment" data-fragment-index="0" --> The intended usage is that one builds either offline (consoles) or during loading time.  (Usually thousands)
* <!-- .element class="fragment" data-fragment-index="0" --> Can be cached, but the app must rebuild on os or gpu changes
* <!-- .element class="fragment" data-fragment-index="0" --> Compiling takes a lot of time 1-2 seconds

--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE BINDING

* <!-- .element class="fragment" data-fragment-index="0" --> Shaders must reference resources
* <!-- .element class="fragment" data-fragment-index="0" --> Constant Buffers – constant memory for the shader
* <!-- .element class="fragment" data-fragment-index="0" --> Unordered Access Views – write for the shader
* <!-- .element class="fragment" data-fragment-index="0" --> Render targets – write for the shader
* <!-- .element class="fragment" data-fragment-index="0" --> Shader Resources Views – read for the shader
* <!-- .element class="fragment" data-fragment-index="0" --> References are descriptors which are bound to an abstraction called Root Signature
* <!-- .element class="fragment" data-fragment-index="0" --> If the contents of the descriptors do not change drivers can cache or optimize

--- VERTICAL SLIDE ---
DIRECTX12 ROOT Signature

* <!-- .element class="fragment" data-fragment-index="0" --> Similar to an API function. 
* <!-- .element class="fragment" data-fragment-index="0" --> Definition of what type of parameters the function to expect
* <!-- .element class="fragment" data-fragment-index="0" --> It may contain
* <!-- .element class="fragment" data-fragment-index="0" --> Descriptor Tables
* <!-- .element class="fragment" data-fragment-index="0" --> One or several tables with descriptors of resources
* <!-- .element class="fragment" data-fragment-index="0" --> Descriptors directly
* <!-- .element class="fragment" data-fragment-index="0" --> Several limited constants embedded directly in the command list
* <!-- .element class="fragment" data-fragment-index="0" --> example, number of a mesh
* <!-- .element class="fragment" data-fragment-index="0" --> Show example here

--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE TRANSITIONS  

* <!-- .element class="fragment" data-fragment-index="0" --> Using resources for reading and writing from different Compute Units must be synchronized so we end up with deterministic data
* <!-- .element class="fragment" data-fragment-index="0" --> Resource transitions are an abstraction that covers under the hood flushes or invalidation of the gpu caches.
* <!-- .element class="fragment" data-fragment-index="0" --> Directx 11 was doing this in the driver.
* <!-- .element class="fragment" data-fragment-index="0" --> Now is offset explicitly to the app

--- VERTICAL SLIDE ---
Directx12 Resource Barсriers

* <!-- .element class="fragment" data-fragment-index="0" --> Transition Barrier
* <!-- .element class="fragment" data-fragment-index="0" --> Transition barrier indicates that a set of subresources transition between different usages
* <!-- .element class="fragment" data-fragment-index="0" --> Aliasing Barrier
* <!-- .element class="fragment" data-fragment-index="0" --> An aliasing barrier indicates a transition between usages of two different resources which have overlapping mappings into the same heap
* <!-- .element class="fragment" data-fragment-index="0" --> Unordered access view barrier
* <!-- .element class="fragment" data-fragment-index="0" --> A UAV barrier indicates that all UAV accesses, both read or write, to a particular resource must complete between any future UAV accesses, both read or write

--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE TRANSITIONS  

* <!-- .element class="fragment" data-fragment-index="0" --> VERTEX_AND_CONSTANT_BUFFER 
* <!-- .element class="fragment" data-fragment-index="0" --> INDEX_BUFFER 
* <!-- .element class="fragment" data-fragment-index="0" --> RENDER_TARGET
* <!-- .element class="fragment" data-fragment-index="0" --> UNORDERED_ACCESS
* <!-- .element class="fragment" data-fragment-index="0" --> DEPTH_WRITE
* <!-- .element class="fragment" data-fragment-index="0" --> DEPTH_READ
* <!-- .element class="fragment" data-fragment-index="0" --> NON_PIXEL_SHADER_RESOURCE 
* <!-- .element class="fragment" data-fragment-index="0" --> PIXEL_SHADER_RESOURCE 
* <!-- .element class="fragment" data-fragment-index="0" --> STREAM_OUT
* <!-- .element class="fragment" data-fragment-index="0" --> INDIRECT_ARGUMENT 
* <!-- .element class="fragment" data-fragment-index="0" --> COPY_DEST 
* <!-- .element class="fragment" data-fragment-index="0" --> COPY_SOURCE 
* <!-- .element class="fragment" data-fragment-index="0" --> RESOLVE_DEST 
* <!-- .element class="fragment" data-fragment-index="0" --> RESOLVE_SOURCE 
* <!-- .element class="fragment" data-fragment-index="0" --> GENERIC_READ 
* <!-- .element class="fragment" data-fragment-index="0" --> PRESENT 
* <!-- .element class="fragment" data-fragment-index="0" --> PREDICATION 
* <!-- .element class="fragment" data-fragment-index="0" --> VIDEO_DECODE_READ,  VIDEO_DECODE_WRITE 
* <!-- .element class="fragment" data-fragment-index="0" --> VIDEO_PROCESS_READ, VIDEO_PROCESS_WRITE VIDEO_ENCODE_READ, VIDEO_ENCODE_WRITE

--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE Transition EXAMPLE

* <!-- .element class="fragment" data-fragment-index="0" --> Depth Write – Depth Read
* <!-- .element class="fragment" data-fragment-index="0" --> When we bind a resource as a depth for write
* <!-- .element class="fragment" data-fragment-index="0" --> It is in compressed form in the gpu memory to accelerate rendering.
* <!-- .element class="fragment" data-fragment-index="0" --> Setting the resource for read triggers decompression, which can be 0.5 ms, depending on the resolution
* <!-- .element class="fragment" data-fragment-index="0" --> What about reading / writing multiple times in this depth resource?

--- VERTICAL SLIDE ---
Directx12 RESOURCЕ TRANSITION EXAMPLE (AMD)

* <!-- .element class="fragment" data-fragment-index="0" --> Delta Color Compression
* <!-- .element class="fragment" data-fragment-index="0" --> Form of lossless compression of the render targets on the GPU
* <!-- .element class="fragment" data-fragment-index="0" --> The key idea is to process whole blocks instead of individual pixels. Inside a block, only one value is stored with full precision, and the rest is stored as a delta – hence the name
* <!-- .element class="fragment" data-fragment-index="0" --> Clear to 0 or 1
* <!-- .element class="fragment" data-fragment-index="0" --> Do not flag render targets as shader readable unless you need them to be

--- VERTICAL SLIDE ---
DIRECTX12 Resource Transition EXAMPLE (AMD)

* <!-- .element class="fragment" data-fragment-index="0" --> Try mipmapping instead of sparsely reading images
* <!-- .element class="fragment" data-fragment-index="0" --> Write all color channels
* <!-- .element class="fragment" data-fragment-index="0" --> Organize G-Buffer Data
* <!-- .element class="fragment" data-fragment-index="0" --> If arbitrarily bit-packing fields into a G-Buffer, put highly correlated bits in the Most Significant Bits (MSBs) and noisy data in the Least Significant Bits (LSBs) of each channel. This will compress better because it responds similarly to typical data patterns.


--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE TRANSITION EXAMPLE (AMD)

* <!-- .element class="fragment" data-fragment-index="0" --> Even when you’ve followed all the rules above, DCC may sometimes get disabled as not all parts of the GPU can read and write compressed data yet. In these cases, the barrier will result in a decompression. It is important to understand when those cases may occur:
* <!-- .element class="fragment" data-fragment-index="0" --> When simultaneously writing and reading compressed targets.
* <!-- .element class="fragment" data-fragment-index="0" --> This is not coherent between metadata and data, so corruption would occur.
* <!-- .element class="fragment" data-fragment-index="0" --> The driver has to play safe – even if there may be simultaneous access it will decompress, so make sure usage flags are properly set in explicit APIs (Direct3D® 12, Vulkan™) and surfaces unbound and/or write-masked off when not intended to be written.
* <!-- .element class="fragment" data-fragment-index="0" --> When the shader can write to the resource as an Unordered Access View (UAV)
* <!-- .element class="fragment" data-fragment-index="0" --> Flagging a texture to be writable as a UAV through the shader currently disallows compression entirely.
* <!-- .element class="fragment" data-fragment-index="0" --> Some drivers may still allow fast clears, then decompress on shader UAV write bind until the next full clear.
* <!-- .element class="fragment" data-fragment-index="0" --> Before using the copy engine.
* <!-- .element class="fragment" data-fragment-index="0" --> Generally once flagged as a copy source or target, we decompress first because we don’t know where it is going.
* <!-- .element class="fragment" data-fragment-index="0" --> Raw copies can be done between surfaces of the same type and size… if the driver knows that this is going to happ

--- VERTICAL SLIDE ---
DIRECTX12 RESOURCE TRANSITION EXAMPLE (AMD)

* <!-- .element class="fragment" data-fragment-index="0" --> Unordered access view barrier
* <!-- .element class="fragment" data-fragment-index="0" --> Used very often when one have two dispatches that follow each other and must use the same resource. So we are sure they get the correct data
* <!-- .element class="fragment" data-fragment-index="0" --> Aliasing Barriers
* <!-- .element class="fragment" data-fragment-index="0" --> Used in cases when one wants to reuse the same memory for different usages. 
* <!-- .element class="fragment" data-fragment-index="0" --> Example in the beginning of the frame as geometry buffer, towards the end as a render target

--- VERTICAL SLIDE ---

* <!-- .element class="fragment" data-fragment-index="0" --> Create PSOs on worker threads asynchronously
* <!-- .element class="fragment" data-fragment-index="0" --> Start using more general PSOs (with generic shaders that compile quickly) first and generate specializations later
* <!-- .element class="fragment" data-fragment-index="0" --> Avoid runtime PSO compilations as they most likely will lead to stalls
* <!-- .element class="fragment" data-fragment-index="0" --> Minimize state changes between PSOs where possible
* <!-- .element class="fragment" data-fragment-index="0" --> Use identical sensible defaults for don’t care fields wherever possible
* <!-- .element class="fragment" data-fragment-index="0" --> Use the /all_resources_bound / D3DCOMPILE_ALL_RESOURCES_BOUND compile flag if possible

--- VERTICAL SLIDE ---
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t toggle between compute and graphics on the same command queue more than absolutely necessary
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t toggle tessellation on/off more than absolutely necessary
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t forget that PSO creation is where shaders get compiled and stalls get introduced

--- VERTICAL SLIDE ---

* <!-- .element class="fragment" data-fragment-index="0" --> Place constants and CBVs (SRVs and UAVs only if you have directly into the root signature if possible on NVIDIA Hardware
* <!-- .element class="fragment" data-fragment-index="0" --> Cache the current values of root constants, CBVs, SRVs and UAVs in CPU memory and only change the contents of the root signature when a true change is detected
* <!-- .element class="fragment" data-fragment-index="0" --> Limit the shader visibility of CBVs, SRVs and UAVs to only the necessary stages
* <!-- .element class="fragment" data-fragment-index="0" --> Minimize the number of Root Signature changes
* <!-- .element class="fragment" data-fragment-index="0" --> Gracefully handle CBV, UAV, SRV and Sampler descriptors on Tier 1 and CBV and UAV descriptors on Tier 2 hardware

--- VERTICAL SLIDE ---

* <!-- .element class="fragment" data-fragment-index="0" --> Don’t group CBVs into CBV descriptor tables that have a different update frequency
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t bloat your root signature and descriptor tables to be able to reuse them
* <!-- .element class="fragment" data-fragment-index="0" --> Don't simultaneously set visible and deny flags for the same shader stages on root table entries
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t place constants SRVs and UAVs directly into the root signature unless you have a lot of draw/dispatch call that can make use of them
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t leave resource bindings undefined after a change of Root Signature

--- VERTICAL SLIDE ---

* <!-- .element class="fragment" data-fragment-index="0" --> Reuse allocators for similarly sized sequence of draw call
* <!-- .element class="fragment" data-fragment-index="0" --> Use 2*T + N allocators minimum
* <!-- .element class="fragment" data-fragment-index="0" --> 2* - one set of lists/allocators from last frame is still being consumed by the GPU and the second set is being built/used in the current frame
* <!-- .element class="fragment" data-fragment-index="0" --> T = #threads creating command lists – please note that allocators are not free threaded!
* <!-- .element class="fragment" data-fragment-index="0" --> N = extra pool for bundles
* <!-- .element class="fragment" data-fragment-index="0" --> Call Allocator::Reset before reusing it in another frame
* <!-- .element class="fragment" data-fragment-index="0" --> Otherwise the allocator will keep on growing until you’ll run out of memory

--- VERTICAL SLIDE ---
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t forget that Allocator and Lists consume GPU memory
* <!-- .element class="fragment" data-fragment-index="0" --> A too large allocators may limit your GPU working set in other undesirable ways
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t create/destroy allocators but reuse allocators
* <!-- .element class="fragment" data-fragment-index="0" --> Save the overhead for allocator creation/destruction
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t reuse for differently sized sequence of draw calls
* <!-- .element class="fragment" data-fragment-index="0" --> This leads to worst case size allocator
* <!-- .element class="fragment" data-fragment-index="0" --> Don't forget to reset the corresponding allocator when resetting a set of command lists
* <!-- .element class="fragment" data-fragment-index="0" --> Not resetting an allocator means leaking memory!
* <!-- .element class="fragment" data-fragment-index="0" --> Don’t free/reuse an Allocator still in use by active command lists
* <!-- .element class="fragment" data-fragment-index="0" --> сThis is illegal and may free or overwrite memory that the command list is still using


--- VERTICAL SLIDE ---
* <!-- .element class="fragment" data-fragment-index="0" --> Minimize the use of barriers and fences
* <!-- .element class="fragment" data-fragment-index="0" --> We have seen redundant barriers and associated wait for idle operations as a major performance problem for DX11 to DX12 ports
* <!-- .element class="fragment" data-fragment-index="0" --> Any barrier or fence can limit parallelism
* <!-- .element class="fragment" data-fragment-index="0" --> Make sure to always use the minimum set of resource usage flags
* <!-- .element class="fragment" data-fragment-index="0" --> Stay away from using D3D12_RESOURCE_USAGE_GENERIC_READ unless you really need every single flag that is set in this combination of flags
* <!-- .element class="fragment" data-fragment-index="0" --> Redundant flags may trigger redundant flushes and stalls and slow down your game unnecessarily
* <!-- .element class="fragment" data-fragment-index="0" --> To reiterate: We have seen redundant and/or overly conservative barrier flags and their associated wait for idle operations as a major performance problem for DX11 to DX12 ports.

--- VERTICAL SLIDE ---
* <!-- .element class="fragment" data-fragment-index="0" --> Specify the minimum set of targets in ID3D12CommandList::ResourceBarrier
* <!-- .element class="fragment" data-fragment-index="0" --> Adding false dependencies adds redundancy
* <!-- .element class="fragment" data-fragment-index="0" --> Group barriers in one call to ID3D12CommandList::ResourceBarrier
* <!-- .element class="fragment" data-fragment-index="0" --> This way the worst case can be picked instead of sequentially going through all barriers
* <!-- .element class="fragment" data-fragment-index="0" --> Use split barriers when possible
* <!-- .element class="fragment" data-fragment-index="0" --> Use the _BEGIN_ONLY/_END_ONLY flags
* <!-- .element class="fragment" data-fragment-index="0" --> This helps the driver doing a more efficient job
* <!-- .element class="fragment" data-fragment-index="0" --> Do use fences to signal events/advance across calls to ExecuteCommandLists


--- VERTICAL SLIDE ---
DIRECTX12 BASICS

* <!-- .element class="fragment" data-fragment-index="0" --> So these are the basics of around 200 functions
* <!-- .element class="fragment" data-fragment-index="0" --> References:
* <!-- .element class="fragment" data-fragment-index="0" --> Gpu open
* <!-- .element class="fragment" data-fragment-index="0" --> Nvidia
* <!-- .element class="fragment" data-fragment-index="0" --> MSDN


--- NEXT SLIDE ---

# Questions?
